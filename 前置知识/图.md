### 图 (Graph)
* 基本组成部分有顶点Vertex与边Edge（又称节点与弧），边可以是有向或者无向的
* 权重表示从一个顶点到另一个节点的代价，即边的权重
* 图G=(V,E),E=(m,n,w)，即E包括两个节点和边的权重
* 路径Path是由边依次连接起来的顶点序列，无权路径的长度是边的数量，带权路径的长度是所有边权重之和
* 圈Cycle是一条首尾顶点相同的路径

### 图的抽象数据类型
* Graph()新建一个空图
* addVertex(vert)向图中添加一个顶点实例
* addEdge(fromVert, toVert)向图中添加一条有向边，用于连接顶点fromVert和toVert
* addEdge(fromVert, toVert, weight)向图中添加一条带权重weight的有向边，用于连接顶点fromVert和toVert
* getVertex(vertKey)在图中找到名为vertKey的顶点
* getVertices()以列表形式返回图中所有顶点
* in 通过vertex in graph这样的语句，在顶点存在时返回True，否则返回False
* **图的实现方法主要有两种主要形式：邻接矩阵、邻接表**
* 邻接矩阵：矩阵的每一行每一列都代表图中的顶点，如果两个之间有边相连，设定行列值为权重；优点是实现简单，但图中如果边数很少则成为稀疏矩阵，效率底下
* 邻接列表：首先创建一个包含所有顶点的列表，列表中的每个顶点关联一个包含与自己相连的节点的列表
* <details>
  <summary><b>图的邻接列表实现</b></summary>
  <pre><code>
    class Vertex: 
        def __init__(self, key): 
            self.id = key  
            self.connectedTo = {} 
        def addNeighbor(self, nbr, weight=0):  
            self.connectedTo[nbr] = weight 
        def __str__(self): 
            return str(self.id) + 'connectedTo:' + str([x.id for x in self.connectedTo]) 
        def getConnections(self): 
            return self.connectedTo.keys()  
        def getId(self): 
            return self.id 
        def getWeight(self, nbr): 
            return self.connectedTo[nbr]
    class Graph: 
        def __init__(self):  
            self.vertList = {}  
            self.numVertices = 0 
        def addVertex(self, key): 
            self.numVertices=self.numVertices + 1 
            newVertex = Vertex(key)  
            self.vertList[key] = newVertex 
            return newVertex 
        def getVertex(self, n): 
            if n in self.vertList: 
                return self.vertList[n]  
            else: 
                return None 
        def __contains__(self, n): 
            return n in self.vertList 
        def addEdge(self, f, t, cost=0): 
            if f not in self.vertList: 
                nv = self.addVertex(f)  
            if t not in self.vertList:  
                nv = self.addVertex(t) 
            self.vertList[f].addNeighbor(self.vertList[t], cost) 
        def getVertices(self): 
            return self.vertList.keys() 
        def __iter__(self): 
            return iter(self.vertList.values())
  </code></pre>
  </details>


### 应用-拓扑排序
* 从工作流程图得到工作次序排列的算法，处理一个**有向无圈图**，输出顶点的线性序列
* 广泛应用在事件的排期上，除此以外还应用在项目管理、数据库查询优化和矩阵乘法的次序优化上








